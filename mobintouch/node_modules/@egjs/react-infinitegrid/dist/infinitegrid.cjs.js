/*
Copyright (c) NAVER Corp.
name: @egjs/react-infinitegrid
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-infinitegrid
version: 3.0.0
*/
'use strict';

var React = require('react');
var NativeInfiniteGrid = require('@egjs/infinitegrid');
var reactDom = require('react-dom');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function LoadingBar(props) {
  return props.loading;
}

function camelize(str) {
  return str.replace(/[\s-_]([a-z])/g, function (all, letter) {
    return letter.toUpperCase();
  });
}

var InfiniteGrid =
/*#__PURE__*/
function (_super) {
  __extends(InfiniteGrid, _super);

  function InfiniteGrid() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      layout: ""
    };
    return _this;
  }

  var __proto = InfiniteGrid.prototype;

  __proto.render = function () {
    var props = this.props;
    var attributes = {};
    var items = this.toItems();
    var Tag = this.props.tag;

    for (var name in props) {
      if (name in InfiniteGrid.defaultProps) {
        continue;
      }

      attributes[name] = props[name];
    }

    var visibleChildren = [];
    var ig = this.ig;

    if (ig) {
      var state = this.state;
      var result = ig.beforeSync(items);
      state.layout = result === "relayout" ? result : state.layout || result;
      visibleChildren = ig.getRenderingItems().map(function (item) {
        return item.jsx;
      });

      if (this.props.loading && ig.isLoading()) {
        visibleChildren.push(React.createElement(LoadingBar, {
          key: "loadingBar",
          loading: this.props.loading
        }));
      }
    } else {
      var groups = NativeInfiniteGrid.categorize(items);

      if (props.status) {
        var _a = props.status._infinite,
            startCursor = _a.startCursor,
            endCursor = _a.endCursor;
        visibleChildren = NativeInfiniteGrid.ItemManager.pluck(groups.slice(startCursor, endCursor + 1), "items").map(function (item) {
          return item.jsx;
        });
      } else if (props.useFirstRender && groups[0]) {
        visibleChildren = groups[0].items.map(function (item) {
          return item.jsx;
        });
      }
    }

    return React.createElement(Tag, __assign({}, attributes), this.renderContainer(visibleChildren));
  };

  __proto.componentDidUpdate = function () {
    var ig = this.ig;
    var state = this.state;
    var layout = state.layout;
    var elements = this.getElements();

    if (this.props.loading && ig.isLoading()) {
      var loadingElement = elements.splice(elements.length - 1, 1)[0];
      ig.setLoadingBar({
        append: loadingElement,
        prepend: loadingElement
      });
    }

    ig.sync(elements);

    if (layout) {
      state.layout = "";
      ig.layout(layout === "relayout");
    }
  };

  __proto.componentDidMount = function () {
    var _this = this;

    this.wrapperElement = reactDom.findDOMNode(this);
    this.ig = new NativeInfiniteGrid(this.wrapperElement, __assign(__assign({}, this.props.options), {
      renderExternal: true
    })).on("render", function (_a) {
      var next = _a.next;

      _this.forceUpdate(function () {
        next();
      });
    });
    var ig = this.ig;
    NativeInfiniteGrid.INFINITEGRID_EVENTS.forEach(function (name) {
      var eventName = camelize("on " + name);
      ig.on(name, function (e) {
        _this.props[eventName](__assign(__assign({}, e), {
          currentTarget: _this
        }));
      });
    });
    ig.setLayout(this.props.layoutType, this.props.layoutOptions);
    var elements = this.getElements();

    if (this.props.status) {
      ig.setStatus(this.props.status, true, elements);
    } else {
      ig.beforeSync(this.toItems());
      ig.layout(true);
    }
  };

  __proto.componentWillUnmount = function () {
    this.ig.destroy();
  };

  __proto.isLoading = function () {
    return this.ig.isLoading();
  };

  __proto.renderContainer = function (children) {
    var _this = this;

    var props = this.props;
    var isOverflowScroll = props.options.isOverflowScroll;

    if (!isOverflowScroll) {
      return children;
    }

    var ContainerTag = props.containerTag;
    return React.createElement(ContainerTag, {
      className: NativeInfiniteGrid.CONTAINER_CLASSNAME,
      ref: function (e) {
        e && (_this.containerElement = e);
      }
    }, children);
  };

  __proto.getElements = function () {
    return [].slice.call((this.containerElement || this.wrapperElement).children);
  };

  __proto.toItems = function () {
    var _a = this.props,
        children = _a.children,
        groupBy = _a.groupBy;
    var reactChildren = React.Children.toArray(children);
    return reactChildren.map(function (child, i) {
      var groupKey = groupBy(child, i);
      var itemKey = child.key;
      return {
        groupKey: groupKey,
        itemKey: itemKey,
        jsx: child
      };
    });
  };

  InfiniteGrid.defaultProps = {
    tag: "div",
    containerTag: "div",
    layoutType: NativeInfiniteGrid.GridLayout,
    options: {},
    layoutOptions: {},
    useFirstRender: true,
    status: null,
    loading: null,
    groupBy: function (item, index) {
      var props = item.props;

      if ("data-groupkey" in props) {
        return props["data-groupkey"];
      } else if ("groupKey" in props) {
        return props.groupKey;
      } else {
        return "";
      }
    },
    onAppend: function () {},
    onPrepend: function () {},
    onLayoutComplete: function () {},
    onImageError: function () {},
    onChange: function () {}
  };

  __decorate([NativeInfiniteGrid.withInfiniteGridMethods], InfiniteGrid.prototype, "ig", void 0);

  return InfiniteGrid;
}(React.Component);

var GridLayout =
/*#__PURE__*/
function (_super) {
  __extends(GridLayout, _super);

  function GridLayout() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  GridLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {
    layoutType: NativeInfiniteGrid.GridLayout
  });
  return GridLayout;
}(InfiniteGrid);

var JustifiedLayout =
/*#__PURE__*/
function (_super) {
  __extends(JustifiedLayout, _super);

  function JustifiedLayout() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  JustifiedLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {
    layoutType: NativeInfiniteGrid.JustifiedLayout
  });
  return JustifiedLayout;
}(InfiniteGrid);

var FrameLayout =
/*#__PURE__*/
function (_super) {
  __extends(FrameLayout, _super);

  function FrameLayout() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  FrameLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {
    layoutType: NativeInfiniteGrid.FrameLayout
  });
  return FrameLayout;
}(InfiniteGrid);

var SquareLayout =
/*#__PURE__*/
function (_super) {
  __extends(SquareLayout, _super);

  function SquareLayout() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SquareLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {
    layoutType: NativeInfiniteGrid.SquareLayout
  });
  return SquareLayout;
}(InfiniteGrid);

var PackingLayout =
/*#__PURE__*/
function (_super) {
  __extends(PackingLayout, _super);

  function PackingLayout() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PackingLayout.defaultProps = __assign(__assign({}, InfiniteGrid.defaultProps), {
    layoutType: NativeInfiniteGrid.PackingLayout
  });
  return PackingLayout;
}(InfiniteGrid);



var modules = ({
    __proto__: null,
    GridLayout: GridLayout,
    JustifiedLayout: JustifiedLayout,
    FrameLayout: FrameLayout,
    SquareLayout: SquareLayout,
    PackingLayout: PackingLayout,
    'default': InfiniteGrid
});

for (var name in modules) {
  InfiniteGrid[name] = modules[name];
}

module.exports = InfiniteGrid;
//# sourceMappingURL=infinitegrid.cjs.js.map
