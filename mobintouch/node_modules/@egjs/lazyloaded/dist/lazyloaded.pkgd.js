/*
Copyright (c) 2017 NAVER Corp.
@egjs/lazyloaded JavaScript library
@egjs/lazyloaded project is licensed under the MIT license


@version 0.0.2
All-in-one packaged file for ease use of '@egjs/lazyloaded' with below dependencies.
- @egjs/component ^2.1.2
NOTE: This is not an official distribution file and is only for user convenience.

*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory((global.eg = global.eg || {}, global.eg.LazyLoaded = {})));
}(this, function (exports) { 'use strict';

  var isWindow = typeof window !== "undefined";
  var ua = isWindow ? window.navigator.userAgent : "";
  var SUPPORT_COMPUTEDSTYLE = isWindow ? !!("getComputedStyle" in window) : false;
  var IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);
  var SUPPORT_ADDEVENTLISTENER = isWindow ? !!("addEventListener" in document) : false;
  var WIDTH = "width";
  var HEIGHT = "height";

  /*
  Copyright (c) 2017 NAVER Corp.
  @egjs/component project is licensed under the MIT license

  @egjs/component JavaScript library
  https://naver.github.io/egjs-component

  @version 2.1.2
  */

  /**
   * Copyright (c) 2015 NAVER Corp.
   * egjs projects are licensed under the MIT license
   */
  function isUndefined(value) {
    return typeof value === "undefined";
  }
  /**
   * A class used to manage events in a component
   * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스
   * @alias eg.Component
   */


  var Component =
  /*#__PURE__*/
  function () {
    var Component =
    /*#__PURE__*/
    function () {
      /**
      * Version info string
      * @ko 버전정보 문자열
      * @name VERSION
      * @static
      * @type {String}
      * @example
      * eg.Component.VERSION;  // ex) 2.0.0
      * @memberof eg.Component
      */

      /**
       * @support {"ie": "7+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}
       */
      function Component() {
        this._eventHandler = {};
        this.options = {};
      }
      /**
       * Triggers a custom event.
       * @ko 커스텀 이벤트를 발생시킨다
       * @param {String} eventName The name of the custom event to be triggered <ko>발생할 커스텀 이벤트의 이름</ko>
       * @param {Object} customEvent Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>
       * @return {Boolean} Indicates whether the event has occurred. If the stop() method is called by a custom event handler, it will return false and prevent the event from occurring. <a href="https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F">Ref</a> <ko>이벤트 발생 여부. 커스텀 이벤트 핸들러에서 stop() 메서드를 호출하면 'false'를 반환하고 이벤트 발생을 중단한다. <a href="https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F">참고</a></ko>
       * @example
      class Some extends eg.Component {
       some(){
       	if(this.trigger("beforeHi")){ // When event call to stop return false.
      	this.trigger("hi");// fire hi event.
       	}
       }
      }
      const some = new Some();
      some.on("beforeHi", (e) => {
      if(condition){
      	e.stop(); // When event call to stop, `hi` event not call.
      }
      });
      some.on("hi", (e) => {
      // `currentTarget` is component instance.
      console.log(some === e.currentTarget); // true
      });
      // If you want to more know event design. You can see article.
      // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F
       */


      var _proto = Component.prototype;

      _proto.trigger = function trigger(eventName, customEvent) {
        if (customEvent === void 0) {
          customEvent = {};
        }

        var handlerList = this._eventHandler[eventName] || [];
        var hasHandlerList = handlerList.length > 0;

        if (!hasHandlerList) {
          return true;
        } // If detach method call in handler in first time then handler list calls.


        handlerList = handlerList.concat();
        customEvent.eventType = eventName;
        var isCanceled = false;
        var arg = [customEvent];
        var i = 0;

        customEvent.stop = function () {
          isCanceled = true;
        };

        customEvent.currentTarget = this;

        for (var _len = arguments.length, restParam = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParam[_key - 2] = arguments[_key];
        }

        if (restParam.length >= 1) {
          arg = arg.concat(restParam);
        }

        for (i = 0; handlerList[i]; i++) {
          handlerList[i].apply(this, arg);
        }

        return !isCanceled;
      };
      /**
       * Executed event just one time.
       * @ko 이벤트가 한번만 실행된다.
       * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>
       * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>
       * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>
       * @example
      class Some extends eg.Component {
       hi() {
         alert("hi");
       }
       thing() {
         this.once("hi", this.hi);
       }
      }
      var some = new Some();
      some.thing();
      some.trigger("hi");
      // fire alert("hi");
      some.trigger("hi");
      // Nothing happens
       */


      _proto.once = function once(eventName, handlerToAttach) {
        if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
          var eventHash = eventName;
          var i;

          for (i in eventHash) {
            this.once(i, eventHash[i]);
          }

          return this;
        } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
          var self = this;
          this.on(eventName, function listener() {
            for (var _len2 = arguments.length, arg = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              arg[_key2] = arguments[_key2];
            }

            handlerToAttach.apply(self, arg);
            self.off(eventName, listener);
          });
        }

        return this;
      };
      /**
       * Checks whether an event has been attached to a component.
       * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.
       * @param {String} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>
       * @return {Boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>
       * @example
      class Some extends eg.Component {
       some() {
         this.hasOn("hi");// check hi event.
       }
      }
       */


      _proto.hasOn = function hasOn(eventName) {
        return !!this._eventHandler[eventName];
      };
      /**
       * Attaches an event to a component.
       * @ko 컴포넌트에 이벤트를 등록한다.
       * @param {eventName} eventName The name of the event to be attached <ko>등록할 이벤트의 이름</ko>
       * @param {Function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>
       * @return {eg.Component} An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>
       * @example
      class Some extends eg.Component {
       hi() {
         console.log("hi");
       }
       some() {
         this.on("hi",this.hi); //attach event
       }
      }
      */


      _proto.on = function on(eventName, handlerToAttach) {
        if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
          var eventHash = eventName;
          var name;

          for (name in eventHash) {
            this.on(name, eventHash[name]);
          }

          return this;
        } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
          var handlerList = this._eventHandler[eventName];

          if (isUndefined(handlerList)) {
            this._eventHandler[eventName] = [];
            handlerList = this._eventHandler[eventName];
          }

          handlerList.push(handlerToAttach);
        }

        return this;
      };
      /**
       * Detaches an event from the component.
       * @ko 컴포넌트에 등록된 이벤트를 해제한다
       * @param {eventName} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>
       * @param {Function} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>
       * @return {eg.Component} An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>
       * @example
      class Some extends eg.Component {
       hi() {
         console.log("hi");
       }
       some() {
         this.off("hi",this.hi); //detach event
       }
      }
       */


      _proto.off = function off(eventName, handlerToDetach) {
        // All event detach.
        if (isUndefined(eventName)) {
          this._eventHandler = {};
          return this;
        } // All handler of specific event detach.


        if (isUndefined(handlerToDetach)) {
          if (typeof eventName === "string") {
            this._eventHandler[eventName] = undefined;
            return this;
          } else {
            var eventHash = eventName;
            var name;

            for (name in eventHash) {
              this.off(name, eventHash[name]);
            }

            return this;
          }
        } // The handler of specific event detach.


        var handlerList = this._eventHandler[eventName];

        if (handlerList) {
          var k;
          var handlerFunction;

          for (k = 0; (handlerFunction = handlerList[k]) !== undefined; k++) {
            if (handlerFunction === handlerToDetach) {
              handlerList = handlerList.splice(k, 1);
              break;
            }
          }
        }

        return this;
      };

      return Component;
    }();

    Component.VERSION = "2.1.2";
    return Component;
  }();

  function getAttribute(el, name) {
    return el.getAttribute(name) || "";
  }
  function toArray(arr) {
    return [].slice.call(arr);
  }
  function isDataAttribute(target, prefix) {
    if (prefix === void 0) {
      prefix = "data-";
    }

    return !!target.getAttribute(prefix + "width");
  }
  function addEvent(element, type, handler) {
    if (SUPPORT_ADDEVENTLISTENER) {
      element.addEventListener(type, handler, false);
    } else if (element.attachEvent) {
      element.attachEvent("on" + type, handler);
    } else {
      element["on" + type] = handler;
    }
  }
  function removeEvent(element, type, handler) {
    if (element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + type, handler);
    } else {
      element["on" + type] = null;
    }
  }
  function innerWidth(el) {
    return getSize(el, "Width");
  }
  function innerHeight(el) {
    return getSize(el, "Height");
  }
  function getStyles(el) {
    return (SUPPORT_COMPUTEDSTYLE ? window.getComputedStyle(el) : el.currentStyle) || {};
  }

  function getSize(el, name) {
    var size = el["client" + name] || el["offset" + name];
    return parseFloat(size || getStyles(el)[name.toLowerCase()]) || 0;
  }

  var elements = [];
  function add(element, prefix) {
    !elements.length && addEvent(window, "resize", resizeAll);
    element.__PREFIX__ = prefix;
    elements.push(element);
    resize(element);
  }
  function remove(element, prefix) {
    var index = elements.indexOf(element);

    if (index < 0) {
      return;
    }

    var fixed = getAttribute(element, prefix + "fixed");
    delete element.__PREFIX__;
    element.style[fixed === HEIGHT ? WIDTH : HEIGHT] = "";
    elements.splice(index, 1);
    !elements.length && removeEvent(window, "resize", resizeAll);
  }

  function resize(element, prefix) {
    if (prefix === void 0) {
      prefix = "data-";
    }

    var elementPrefix = element.__PREFIX__;

    if (typeof elementPrefix !== "string") {
      elementPrefix = prefix;
    }

    var dataWidth = parseInt(getAttribute(element, "" + elementPrefix + WIDTH), 10) || 0;
    var dataHeight = parseInt(getAttribute(element, "" + elementPrefix + HEIGHT), 10) || 0;
    var fixed = getAttribute(element, elementPrefix + "fixed");

    if (fixed === HEIGHT) {
      var size = innerHeight(element) || dataHeight;
      element.style[WIDTH] = dataWidth / dataHeight * size + "px";
    } else {
      var size = innerWidth(element) || dataWidth;
      element.style[HEIGHT] = dataHeight / dataWidth * size + "px";
    }
  }

  function resizeAll() {
    elements.forEach(function (element) {
      resize(element);
    });
  }

  /**
   * @namespace eg.LazyLoaded
   */

  /**
   * This module is used to wait for images or videos to load.
   * @ko 이 모듈은 이미지 또는 비디오 로딩을 대기할 수 있습니다.
   * @memberof eg.LazyLoaded
   * @param -
   * @example
   * ## HTML
   * ```html
   * <div>
   *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
   *    <img src="./2.jpg">
   *    <img src="./3.jpg">
   *    <img src="./4.jpg">
   *    <img src="ERR">
   *    <img src="./6.jpg">
   *    <img src="./7.jpg">
   *    <img src="ERR">
   * </div>
   * ```
   * ## Javascript
   * ```js
   * import {check} from "@egjs/lazyloaded";
   *
   * eg.LazyLoaded.check([document.querySelector("div")]).on({
   *   ready: () => console.log("ready"),
   *   finish: () => console.log("finish"),
   *   error: e => console.log("error", e),
   * });
   * ```
   */

  function check(elements, prefix) {
    if (prefix === void 0) {
      prefix = "data-";
    }

    var component = new Component();
    var finishCount = 0;
    var readyCount = 0;

    function checkReady() {
      if (--readyCount !== 0) {
        return;
      }
      /**
       * An event occurs when the size of all images is available.
       * @ko 모든 이미지의 사이즈를 구할 수 있는 상태가 된 경우 이벤트가 발생한다.
       * @event eg.LazyLoaded#ready
       * @example
       * ```html
       * <div>
       *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
       *    <img src="./2.jpg"/>
       *    <img src="ERR"/>
       * </div>
       * ```
       * ## Javascript
       * ```js
       * import {check} from "@egjs/lazyloaded";
       *
       * eg.LazyLoaded.check([document.querySelector("div")]).on({
       *   ready: () => console.log("ready"),
       * });
       * ```
       */


      component.trigger("ready");
    }

    function checkFinish() {
      if (--finishCount !== 0) {
        return;
      }
      /**
       * An event occurs when all images have been completed loading.
       * @ko 모든 이미지가 로딩이 완료된 상태가 된 경우 이벤트가 발생한다.
       * @event eg.LazyLoaded#finish
       * @example
       * ```html
       * <div>
       *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
       *    <img src="./2.jpg"/>
       *    <img src="ERR"/>
       * </div>
       * ```
       * ## Javascript
       * ```js
       * import {check} from "@egjs/lazyloaded";
       *
       * eg.LazyLoaded.check([document.querySelector("div")]).on({
       *   finish: () => console.log("finish"),
       * });
       * ```
       */


      component.trigger("finish");
    }

    elements.forEach(function (el, i) {
      var tagName = el.tagName;

      if (isDataAttribute(el, prefix) && tagName !== "IMG") {
        add(el, prefix);
        ++finishCount;
        setTimeout(function () {
          check(toArray(el.querySelectorAll("img")), prefix).on("finish", function () {
            remove(el, prefix);
            checkFinish();
          });
        });
        return;
      }

      var images = tagName === "IMG" ? [el] : toArray(el.querySelectorAll("img"));

      if (!images.length) {
        return;
      }

      images.forEach(function (img, j) {
        if (img.complete && (!IS_IE || IS_IE && img.naturalWidth)) {
          if (!img.naturalWidth) {
            setTimeout(function () {
              component.trigger("error", {
                itemTarget: el,
                itemIndex: i,
                target: img,
                index: j
              });
            });
          }

          return;
        }

        if (isDataAttribute(img, prefix)) {
          add(img, prefix);
        } else {
          ++readyCount;
        }

        ++finishCount;

        function onError() {
          /**
           * An event occurs if the image fails to load.
           * @ko 이미지가 로딩에 실패하면 이벤트가 발생한다.
           * @event eg.LazyLoaded#error
           * @param {object} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
           * @param {HTMLElement} [e.itemTarget] - The item's element with error images.<ko>오류난 이미지가 있는 아이템의 엘리먼트</ko>
           * @param {number} [e.itemindex] - The item's index with error images. <ko>오류난 이미지가 있는 아이템의 인덱스</ko>
           * @param {HTMLElement} [e.target] - Error image element <ko>오류난 이미지 엘리먼트</ko>
           * @param {number} [e.index] - Error image index <ko>오류난 이미지의 인덱스</ko>
           * @example
           * ```html
           * <div>
           *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
           *    <img src="./2.jpg"/>
           *    <img src="ERR"/>
           * </div>
           * ```
           * ## Javascript
           * ```js
           * import {check} from "@egjs/lazyloaded";
           *
           * eg.LazyLoaded.check([document.querySelector("div")]).on({
           *   error: e => {
           *     // <div>...</div>, 0, <img src="ERR"/>, 2
           *     console.log(e.itemTarget, e.itemIndex, e.target, e.index),
           *   },
           * });
           * ```
           */
          component.trigger("error", {
            itemTarget: el,
            itemIndex: i,
            target: img,
            index: j
          });
        }

        function onCheck(e) {
          var target = e.target || e.srcElement;
          removeEvent(target, "error", onCheck);
          removeEvent(target, "load", onCheck);

          if (isDataAttribute(target, prefix)) {
            remove(target, prefix);
          } else {
            checkReady();
          }

          if (e.type === "error") {
            onError();
          }

          checkFinish();
        }

        addEvent(img, "load", onCheck);
        addEvent(img, "error", onCheck);
        IS_IE && img.setAttribute("src", img.getAttribute("src"));
      });
    });
    !readyCount && setTimeout(function () {
      component.trigger("ready");
    });
    !finishCount && setTimeout(function () {
      component.trigger("finish");
    });
    return component;
  }

  exports.check = check;
  exports.removeAutoSizer = remove;

}));
//# sourceMappingURL=lazyloaded.pkgd.js.map
