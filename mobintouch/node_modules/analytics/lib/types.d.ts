/**
 * Core Analytic constants. These are exposed for third party plugins & listeners
 * @typedef {Object} constants
 * @property {ANON_ID} ANON_ID - Anonymous visitor Id localstorage key
 * @property {USER_ID} USER_ID - Visitor Id localstorage key
 * @property {USER_TRAITS} USER_TRAITS - Visitor traits localstorage key
 */
declare type constants = {
    ANON_ID: ANON_ID;
    USER_ID: USER_ID;
    USER_TRAITS: USER_TRAITS;
};

/**
 * Anonymous visitor Id localstorage key
 * @typedef {String} ANON_ID
 */
declare type ANON_ID = string;

/**
 * Visitor Id localstorage key
 * @typedef {String} USER_ID
 */
declare type USER_ID = string;

/**
 * Visitor traits localstorage key
 * @typedef {String} USER_TRAITS
 */
declare type USER_TRAITS = string;

/**
 * Analytics library configuration
 *
 * After the library is initialized with config, the core API is exposed and ready for use in the application.
 *
 * @param {object} config - analytics core config
 * @param {string} [config.app] - Name of site / app
 * @param {string} [config.version] - Version of your app
 * @param {Array.<Object>}  [config.plugins] - Array of analytics plugins
 * @return {AnalyticsInstance} Analytics Instance
 * @example
 *
 * import Analytics from 'analytics'
 * import pluginABC from 'analytics-plugin-abc'
 * import pluginXYZ from 'analytics-plugin-xyz'
 *
 * // initialize analytics
 * const analytics = Analytics({
 *   app: 'my-awesome-app',
 *   plugins: [
 *     pluginABC,
 *     pluginXYZ
 *   ]
 * })
 *
 */
declare function analytics(config: {
    app?: string;
    version?: string;
    plugins?: object[];
}): AnalyticsInstance;

/**
 * Analytic instance returned from initialization
 * @typedef {Object} AnalyticsInstance
 * @property {Identify} identify - Identify a user
 * @property {Track} track - Track an analytics event
 * @property {Page} page - Trigger page view
 * @property {User} user - Get user data
 * @property {Reset} reset - Clear information about user & reset analytics
 * @property {Ready} ready - Fire callback on analytics ready event
 * @property {On} on - Fire callback on analytics lifecycle events.
 * @property {Once} once - Fire callback on analytics lifecycle events once.
 * @property {GetState} getState - Get data about user, activity, or context.
 * @property {Storage} storage - storage methods
 * @property {EnablePlugin} enablePlugin - Enable plugin
 * @property {DisablePlugin} disablePlugin - Disable plugin
 */
declare type AnalyticsInstance = {
    identify: Identify;
    track: Track;
    page: Page;
    user: User;
    reset: Reset;
    ready: Ready;
    on: On;
    once: Once;
    getState: GetState;
    storage: Storage;
    enablePlugin: EnablePlugin;
    disablePlugin: DisablePlugin;
};

/**
 * Identify a user. This will trigger `identify` calls in any installed plugins and will set user data in localStorage
 * @typedef {Function} Identify
 * @param  {String}   userId  - Unique ID of user
 * @param  {Object}   [traits]  - Object of user traits
 * @param  {Object}   [options] - Options to pass to identify call
 * @param  {Function} [callback] - Callback function after identify completes
 * @api public
 *
 * @example
 *
 * // Basic user id identify
 * analytics.identify('xyz-123')
 *
 * // Identify with additional traits
 * analytics.identify('xyz-123', {
 *   name: 'steve',
 *   company: 'hello-clicky'
 * })
 *
 * // Disable identify for specific plugin
 * analytics.identify('xyz-123', {}, {
 *  plugins: {
 *    // disable for segment plugin
 *    segment: false
 *  }
 * })
 *
 * // Fire callback with 2nd or 3rd argument
 * analytics.identify('xyz-123', () => {
 *   console.log('do this after identify')
 * })
 */
declare type Identify = (userId: string, traits?: any, options?: any, callback?: (...params: any[]) => any) => void;

/**
 * Track an analytics event. This will trigger `track` calls in any installed plugins
 * @typedef {Function} Track
 * @param  {String}   eventName - Event name
 * @param  {Object}   [payload]   - Event payload
 * @param  {Object}   [options]   - Event options
 * @param  {Function} [callback]  - Callback to fire after tracking completes
 * @api public
 *
 * @example
 *
 * // Basic event tracking
 * analytics.track('buttonClicked')
 *
 * // Event tracking with payload
 * analytics.track('itemPurchased', {
 *   price: 11,
 *   sku: '1234'
 * })
 *
 * // Disable specific plugin on track
 * analytics.track('cartAbandoned', {
 *   items: ['xyz', 'abc']
 * }, {
 *  plugins: {
 *    // disable track event for segment
 *    segment: false
 *  }
 * })
 *
 * // Fire callback with 2nd or 3rd argument
 * analytics.track('newsletterSubscribed', () => {
 *   console.log('do this after track')
 * })
 */
declare type Track = (eventName: string, payload?: any, options?: any, callback?: (...params: any[]) => any) => void;

/**
 * Trigger page view. This will trigger `page` calls in any installed plugins
 * @typedef {Function} Page
 * @param  {PageData} [data] - Page data overrides.
 * @param  {Object}   [options] - Page tracking options
 * @param  {Function} [callback] - Callback to fire after page view call completes
 * @api public
 *
 * @example
 *
 * // Basic page tracking
 * analytics.page()
 *
 * // Page tracking with page data overides
 * analytics.page({
 *   url: 'https://google.com'
 * })
 *
 * // Disable specific plugin page tracking
 * analytics.page({}, {
 *  plugins: {
 *    // disable page tracking event for segment
 *    segment: false
 *  }
 * })
 *
 * // Fire callback with 1st, 2nd or 3rd argument
 * analytics.page(() => {
 *   console.log('do this after page')
 * })
 */
declare type Page = (data?: PageData, options?: any, callback?: (...params: any[]) => any) => void;

/**
 * Get user data
 * @typedef {Function} User
 * @param {string} [key] - dot.prop.path of user data. Example: 'traits.company.name'
 * @returns {string|object} value of user data or null
 *
 * @example
 *
 * // Get all user data
 * const userData = analytics.user()
 *
 * // Get user id
 * const userId = analytics.user('userId')
 *
 * // Get user company name
 * const companyName = analytics.user('traits.company.name')
 */
declare type User = (key?: string) => string | any;

/**
 * Clear all information about the visitor & reset analytic state.
 * @typedef {Function} Reset
 * @param {Function} [callback] - Handler to run after reset
 *
 * @example
 *
 * // Reset current visitor
 * analytics.reset()
 */
declare type Reset = (callback?: (...params: any[]) => any) => void;

/**
 * Fire callback on analytics ready event
 * @typedef {Function} Ready
 * @param  {Function} callback - function to trigger when all providers have loaded
 * @returns {DetachListeners} - Function to detach listener
 *
 * @example
 *
 * analytics.ready() => {
 *   console.log('all plugins have loaded or were skipped', payload)
 * })
 */
declare type Ready = (callback: (...params: any[]) => any) => DetachListeners;

/**
 * Attach an event handler function for analytics lifecycle events.
 * @typedef {Function} On
 * @param  {String}   name - Name of event to listen to
 * @param  {Function} callback - function to fire on event
 * @return {DetachListeners} - Function to detach listener
 *
 * @example
 *
 * // Fire function when 'track' calls happen
 * analytics.on('track', ({ payload }) => {
 *   console.log('track call just happened. Do stuff')
 * })
 *
 * // Remove listener before it is called
 * const removeListener = analytics.on('track', ({ payload }) => {
 *   console.log('This will never get called')
 * })
 *
 * // cleanup .on listener
 * removeListener()
 */
declare type On = (name: string, callback: (...params: any[]) => any) => DetachListeners;

/**
 * Detach listeners
 * @typedef {Function} DetachListeners
 */
declare type DetachListeners = () => void;

/**
 * Attach a handler function to an event and only trigger it only once.
 * @typedef {Function} Once
 * @param  {String} name - Name of event to listen to
 * @param  {Function} callback - function to fire on event
 * @return {DetachListeners} - Function to detach listener
 *
 * @example
 *
 * // Fire function only once 'track'
 * analytics.once('track', ({ payload }) => {
 *   console.log('This will only triggered once when analytics.track() fires')
 * })
 *
 * // Remove listener before it is called
 * const listener = analytics.once('track', ({ payload }) => {
 *   console.log('This will never get called b/c listener() is called')
 * })
 *
 * // cleanup .once listener before it fires
 * listener()
 */
declare type Once = (name: string, callback: (...params: any[]) => any) => DetachListeners;

/**
 * Get data about user, activity, or context. Access sub-keys of state with `dot.prop` syntax.
 * @typedef {Function} GetState
 * @param  {string} [key] - dot.prop.path value of state
 * @return {any}
 *
 * @example
 *
 * // Get the current state of analytics
 * analytics.getState()
 *
 * // Get a subpath of state
 * analytics.getState('context.offline')
 */
declare type GetState = (key?: string) => any;

/**
 * Enable analytics plugin
 * @typedef {Function} EnablePlugin
 * @param  {String|Array} plugins - name of plugins(s) to disable
 * @param  {Function} [callback] - callback after enable runs
 * @example
 *
 * analytics.enablePlugin('google')
 *
 * // Enable multiple plugins at once
 * analytics.enablePlugin(['google', 'segment'])
 */
declare type EnablePlugin = (plugins: string | any[], callback?: (...params: any[]) => any) => void;

/**
 * Disable analytics plugin
 * @typedef {Function} DisablePlugin
 * @param  {String|Array} name - name of integration(s) to disable
 * @param  {Function} callback - callback after disable runs
 * @example
 *
 * analytics.disablePlugin('google')
 *
 * analytics.disablePlugin(['google', 'segment'])
 */
declare type DisablePlugin = (name: string | any[], callback: (...params: any[]) => any) => void;

/**
 * Storage utilities for persisting data.
 * These methods will allow you to save data in localStorage, cookies, or to the window.
 * @typedef {Object} Storage
 * @property {GetItem} getItem - Get value from storage
 * @property {SetItem} setItem - Set storage value
 * @property {RemoveItem} removeItem - Remove storage value
 *
 * @example
 *
 * // Pull storage off analytics instance
 * const { storage } = analytics
 *
 * // Get value
 * storage.getItem('storage_key')
 *
 * // Set value
 * storage.setItem('storage_key', 'value')
 *
 * // Remove value
 * storage.removeItem('storage_key')
 */
declare type Storage = {
    getItem: GetItem;
    setItem: SetItem;
    removeItem: RemoveItem;
};

/**
 * Get value from storage
 * @typedef {Function} GetItem
 * @param {String} key - storage key
 * @param {Object} [options] - storage options
 * @return {Any}
 *
 * @example
 *
 * analytics.storage.getItem('storage_key')
 */
declare type GetItem = (key: string, options?: any) => any;

/**
 * Set storage value
 * @typedef {Function} SetItem
 * @param {String} key - storage key
 * @param {any} value - storage value
 * @param {Object} [options] - storage options
 *
 * @example
 *
 * analytics.storage.setItem('storage_key', 'value')
 */
declare type SetItem = (key: string, value: any, options?: any) => void;

/**
 * Remove storage value
 * @typedef {Function} RemoveItem
 * @param {String} key - storage key
 * @param {Object} [options] - storage options
 *
 * @example
 *
 * analytics.storage.removeItem('storage_key')
 */
declare type RemoveItem = (key: string, options?: any) => void;

/**
 * Async reduce over matched plugin methods
 * Fires plugin functions
 */
declare function processEvent(): void;

/**
 * Return array of event names
 * @param  {String} eventType - original event type
 * @param  {String} namespace - optional namespace postfix
 * @return {array} - type, method, end
 */
declare function getEventNames(eventType: string, namespace: string): any[];

/**
 * Generate arguments to pass to plugin methods
 * @param  {Object} instance - analytics instance
 * @param  {array} abortablePlugins - plugins that can be cancelled by caller
 * @return {*} function to inject plugin params
 */
declare function argumentFactory(instance: any, abortablePlugins: any[]): any;

/**
 * Verify plugin is not calling itself with whatever:myPluginName self refs
 */
declare function validateMethod(): void;

/**
 * Return the canonical URL and rmove the hash.
 * @param  {string} search - search param
 * @return {string} return current canonical URL
 */
declare function currentUrl(search: string): string;

/**
 * Page data for overides
 * @typedef {object} PageData
 * @property {string} [title] - Page title
 * @property {string} [url] - Page url
 * @property {string} [path] - Page path
 * @property {string} [search] - Page search
 * @property {string} [width] - Page width
 * @property {string} [height] - Page height
 */
declare type PageData = {
    title?: string;
    url?: string;
    path?: string;
    search?: string;
    width?: string;
    height?: string;
};

/**
 * Get information about current page
 * @typedef {Function} getPageData
 * @param  {PageData} [pageData = {}] - Page data overides
 * @return {PageData} resolved page data
 */
declare type getPageData = (pageData?: PageData) => PageData;

/**
 * @typedef {Object} AnalyticsPlugin
 * @property {string} NAMESPACE - Name of plugin
 * @property {Object} [EVENTS] - exposed events of plugin
 * @property {Object} [config] - Configuration of plugin
 * @property {function} [initialize] - Load analytics scripts method
 * @property {function} [page] - Page visit tracking method
 * @property {function} [track] - Custom event tracking method
 * @property {function} [identify] - User identify method
 * @property {function} [loaded] - Function to determine if analytics script loaded
 * @property {function} [ready] - Fire function when plugin ready
 */
declare type AnalyticsPlugin = {
    NAMESPACE: string;
    EVENTS?: any;
    config?: any;
    initialize?: (...params: any[]) => any;
    page?: (...params: any[]) => any;
    track?: (...params: any[]) => any;
    identify?: (...params: any[]) => any;
    loaded?: (...params: any[]) => any;
    ready?: (...params: any[]) => any;
};


export const CONSTANTS: constants;

export const init = analytics;

export const Analytics = analytics;

export = analytics;